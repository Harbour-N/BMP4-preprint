{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Simulated control\n",
        "description: Simulate the model with parameter values drawn from real patient data and see how it matches with the real data\n",
        "authors:\n",
        "  - name: Nicholas Harbour\n",
        "  - name: Markus Owen\n",
        "format: \n",
        "  html:\n",
        "    embed-resources: true\n",
        "    code-fold: true\n",
        "    number-sections: true\n",
        "    toc: true\n",
        "    toc-depth: 3\n",
        "    date: now\n",
        "    date-modified: last-modified\n",
        "    date-format: \"MMMM DD, YYYY, HH:mm:ss\"\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "# import packages and define functions\n"
      ],
      "id": "46419c7d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Import_packages\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import pandas as pd\n",
        "import scipy.stats as stats\n",
        "from scipy.stats import lognorm\n",
        "from numba import jit\n",
        "from sksurv.compare import compare_survival\n",
        "from sksurv.nonparametric import kaplan_meier_estimator"
      ],
      "id": "Import_packages",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "all functions are in: \"notebooks/gsc_model_functions.py\"\n"
      ],
      "id": "27010c5a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: import_functions\n",
        "\n",
        "import gsc_model_functions as gmf"
      ],
      "id": "import_functions",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "For this we need to load in the patient data and calculate the distribution params"
      ],
      "id": "572b3882"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Load_the_real_data\n",
        "\n",
        "# load in the patient survival data\n",
        "historic_df = pd.read_csv(\"Data/Rho_D_data.csv\")\n",
        "censored_str = \"Censorship (1=censored)\"\n",
        "survival_str = \"Overall Survival\"\n",
        "# only keep patients that weren't censored\n",
        "historic_df = historic_df[historic_df[censored_str] == 0]\n",
        "# cut off patients that had very high proliferation rate\n",
        "historic_df = historic_df[historic_df[\"PIHNA rho\"] < 100 ] \n",
        "historic_df[censored_str] = True\n",
        "\n",
        "# fit distribution to the data\n",
        "dist_name = 'lognorm'  # Replace with the desired distribution name\n",
        "dist = getattr(stats, dist_name)\n",
        "params = dist.fit(historic_df[\"PIHNA rho\"])\n",
        "    \n",
        "shape = params[0]\n",
        "loc = params[1]\n",
        "scale = params[-1]"
      ],
      "id": "Load_the_real_data",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Set parameters for simulated control case\n"
      ],
      "id": "512ee4aa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: simulated_control_pars\n",
        "\n",
        "### import params\n",
        "from gsc_model_params import *\n",
        "\n",
        "# initial conditions\n",
        "n0 = 0.001\n",
        "s0 = 0.01*n0 # fraction of initial tumour\n",
        "v_ratio = 1.95 # ratio between successive compartments\n",
        "v0 = ((n0-s0)*(v_ratio-1)/(v_ratio**n-1))*(v_ratio**np.arange(n))\n",
        "u0 = np.zeros(n+1)\n",
        "u0[0] = s0\n",
        "u0[1:] = v0\n",
        "\n",
        "n_patients = 200 # set the number of patients to simulate\n",
        "n_patients = len(historic_df) # set the number of patients to simulate\n",
        "surv_final = np.zeros([n_patients,2]) # store the final survival time for each patient\n",
        "tp1 = np.zeros([n_patients,2]) \n",
        "tp2 = np.zeros([n_patients,2]) \n",
        "\n",
        "t_final = 8000\n",
        "dt = 0.01\n",
        "t = np.arange(0, t_final+dt/2, dt)\n",
        "\n",
        "# generate rhos as sample from lognormal distribution\n",
        "np.random.seed(1)\n",
        "pro_rates_sampled = np.sort(lognorm.rvs(shape, loc , scale=scale, size=n_patients))\n",
        "# pro_rates_sampled = np.sort(historic_df[\"PIHNA rho\"])\n",
        "\n",
        "BMP4_on = 0 # BMP4 off\n",
        "resect_on = 1 # resection on\n",
        "\n",
        "N_save_set = []\n",
        "u_save_set = []\n",
        "t_save_set = []\n",
        "s_save_set = []\n"
      ],
      "id": "simulated_control_pars",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Simulate virtual controls: Resection + RT\n",
        "\n",
        "Simulate the model for a cohort of virtual patients who have resection only.\n"
      ],
      "id": "e89327c9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: resection_model_sims\n",
        "\n",
        "rad_on = 1 # RT on\n",
        "\n",
        "surv_final_control = np.zeros(n_patients)\n",
        "\n",
        "alphas = np.zeros(n_patients) # to store the set of alphas used\n",
        "\n",
        "N_save = [] # save the total tumor size for each virtual patient \n",
        "u_save = [] # save the total tumor size for each virtual patient \n",
        "t_save = [] # save the time for each virtual patient\n",
        "s_save = [] # save stem cell variable\n",
        "save_detect_size = [] # save the size of the tumor at detection\n",
        "save_detect_t = [] # save the time of detection\n",
        "\n",
        "# we want each patient to have a unique random seed so that across all simulations they get the same series of random numbers\n",
        "random_seeds = np.arange(0,n_patients,1)\n",
        "\n",
        "for j in range(n_patients):\n",
        "    \n",
        "    np.random.seed(random_seeds[j]) # patient specific random seed\n",
        "    mv = mv_rho_scale*pro_rates_sampled[j]*np.ones(n) \n",
        "    ms = ms_mv_scale*mv[0]\n",
        "    mv[n-1] = 0 \n",
        "    \n",
        "    # calc alpha as proportional to rho\n",
        "    alpha = gmf.calc_alpha_from_rho(pro_rates_sampled[j])\n",
        "    beta = gmf.calc_beta(alpha)\n",
        "    alphas[j] = alpha\n",
        "     \n",
        "    u,N,VS,t,m,B,detect_size,detect_t,tp1[j,0],tp2[j,0] = gmf.simulate_model(t_final,dt,u0,psi,Ps_max,Ps_min,n,k,ms,mv,delta_s,delta_v,delta_m,delta_b,C,u_s,n_RT_repeat,n_RT_cycles,rad_on,alpha,beta,eta,mu,t_RT_wait,t_RT_interval,detect_threshold,detection_sensitivity,death_sensitivity,lam,resection_to_RT_delay,BMP4_on,death_threshold,resect_on,resect_fraction,random_seeds[j],m_init)\n",
        "    \n",
        "    surv_final[j,0] =  t[-1]-detect_t\n",
        "    surv_final_control[j] = t[-1]-detect_t\n",
        "    N_save.append(N)\n",
        "    u_save.append(u)\n",
        "    t_save.append(t)\n",
        "    s_save.append(u[:,0])\n",
        "    save_detect_size.append(detect_size)\n",
        "    save_detect_t.append(detect_t)\n",
        " \n",
        "N_save_set.append(N_save)\n",
        "u_save_set.append(u_save)\n",
        "t_save_set.append(t_save)\n",
        "s_save_set.append(s_save)"
      ],
      "id": "resection_model_sims",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Simulate BMP4 on virtual control patients\n",
        "\n",
        "Simulate the model for a cohort of virtual patients who undergo standard of care treatment, resection followed by radiotherapy.\n"
      ],
      "id": "fd275711"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: resection_RT_model_sims\n",
        "\n",
        "rad_on = 1 # RT on\n",
        "BMP4_on = 1 # BMP4 on\n",
        "\n",
        "surv_final_BMP41 = np.zeros(n_patients)\n",
        "\n",
        "alphas = np.zeros(n_patients) # to store the set of alphas used\n",
        "\n",
        "N_save = [] # save the total tumor size for each virtual patient \n",
        "u_save = [] # save the total tumor size for each virtual patient \n",
        "t_save = [] # save the time for each virtual patient\n",
        "s_save = [] # save stem cell variable\n",
        "save_detect_size = [] # save the size of the tumor at detection\n",
        "save_detect_t = [] # save the time of detection\n",
        "save_detect_s = [] # save s at detection\n",
        "\n",
        "for j in range(n_patients):\n",
        "    \n",
        "    np.random.seed(random_seeds[j]) # patient specific random seed\n",
        "    mv = mv_rho_scale*pro_rates_sampled[j]*np.ones(n) \n",
        "    ms = ms_mv_scale*mv[0]\n",
        "    mv[n-1] = 0 \n",
        "    \n",
        "    # calc alpha as proportional to rho\n",
        "    alpha = gmf.calc_alpha_from_rho(pro_rates_sampled[j])\n",
        "    beta = gmf.calc_beta(alpha)\n",
        "    alphas[j] = alpha\n",
        "     \n",
        "    u,N,VS,t,m,B,detect_size,detect_t,tp1[j,1],tp2[j,1] = gmf.simulate_model(t_final,dt,u0,psi,Ps_max,Ps_min,n,k,ms,mv,delta_s,delta_v,delta_m,delta_b,C,u_s,n_RT_repeat,n_RT_cycles,rad_on,alpha,beta,eta,mu,t_RT_wait,t_RT_interval,detect_threshold,detection_sensitivity,death_sensitivity,lam,resection_to_RT_delay,BMP4_on,death_threshold,resect_on,resect_fraction,random_seeds[j],m_init)\n",
        "    \n",
        "    surv_final[j,1] =  t[-1]-detect_t\n",
        "    surv_final_BMP41[j] = t[-1]-detect_t\n",
        "    N_save.append(N)\n",
        "    u_save.append(u)\n",
        "    t_save.append(t)\n",
        "    s_save.append(u[:,0])\n",
        "    save_detect_size.append(detect_size)\n",
        "    save_detect_t.append(detect_t)\n",
        " \n",
        "N_save_set.append(N_save)\n",
        "u_save_set.append(u_save)\n",
        "t_save_set.append(t_save)\n",
        "s_save_set.append(s_save)\n"
      ],
      "id": "resection_RT_model_sims",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Example tumour trajectories: control (resection + RT), compared to BMP4\n",
        "\n",
        "Plot representative examples of tumour growth\n"
      ],
      "id": "16e6c2af"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-resection-RT-model-sims\n",
        "#| fig-cap: Example tumour trajectories for resection alone (solid curves) and resection plus radiotherapy (dashed curves). Radiotherapy enhances survival but causes a transient increase in stem cell fraction.\n",
        "#| fig-alt: Example tumour trajectories for resection alone (solid curves) and resection plus radiotherapy (dashed curves).\n",
        "\n",
        "n_patients_to_plot = 10\n",
        "\n",
        "colours = [\"tab:blue\", \"tab:orange\", \"tab:green\", \"tab:red\", \"tab:purple\", \"tab:brown\", \"tab:pink\", \"tab:gray\", \"tab:olive\", \"tab:cyan\"]\n",
        "\n",
        "fig, (ax1,ax2,ax3) = plt.subplots(3, sharex=True) \n",
        "q = 0 # loop through colors\n",
        "\n",
        "index_to_plot = [30, 50, 90, 130, 190]\n",
        "\n",
        "for i in index_to_plot:\n",
        "    print(i)\n",
        "    ax1.plot(t_save_set[0][i],N_save_set[0][i],color=colours[q],alpha=0.5)\n",
        "    ax1.plot(t_save_set[1][i],N_save_set[1][i],'--',color=colours[q],alpha=0.5)\n",
        "\n",
        "    ax2.plot(t_save_set[0][i],s_save_set[0][i],color=colours[q],alpha=0.5)\n",
        "    ax2.plot(t_save_set[1][i],s_save_set[1][i],'--',color=colours[q],alpha=0.5)\n",
        "\n",
        "    ax3.plot(t_save_set[0][i],s_save_set[0][i]/N_save_set[0][i],color=colours[q],alpha=0.5)\n",
        "    ax3.plot(t_save_set[1][i],s_save_set[1][i]/N_save_set[1][i],'--',color=colours[q],alpha=0.5)\n",
        "\n",
        "    q = q+1\n",
        "\n",
        "    if save_detect_t[i] > 0:\n",
        "        ax1.plot(save_detect_t[i],save_detect_size[i],'r*')\n",
        "        ax2.plot(save_detect_t[i],s_save[i][t_save[i]==save_detect_t[i]],'r*')\n",
        "        ax3.plot(save_detect_t[i],s_save[i][t_save[i]==save_detect_t[i]]/save_detect_size[i],'r*')\n",
        "\n",
        "        iRT = np.where(np.abs(t_save[i]-save_detect_t[i]-resection_to_RT_delay)<dt/2)[0]\n",
        "        if len(iRT>0): # if RT starts before death\n",
        "            ax1.plot(save_detect_t[i]+resection_to_RT_delay,N_save[i][iRT],'b.')\n",
        "            ax2.plot(save_detect_t[i]+resection_to_RT_delay,s_save[i][iRT],'b.')\n",
        "            ax3.plot(save_detect_t[i]+resection_to_RT_delay,s_save[i][iRT]/N_save[i][iRT],'b.')\n",
        "\n",
        "ax1.set_xlim([0, 2000])\n",
        "#ax1.set_ylim([0, 0.55])\n",
        "ax1.set_ylabel('Tumor size', fontsize=14)\n",
        "\n",
        "ax2.set_yscale('log')\n",
        "#ax2.set_ylim([0, 0.0012])\n",
        "ax2.set_ylabel('GSC cells', fontsize=14)\n",
        "\n",
        "# ax3.set_ylim([0, 0.06])\n",
        "ax3.set_xlabel('Time (days)', fontsize=14)\n",
        "ax3.set_ylabel('GSC fraction', fontsize=14)\n",
        "\n",
        "plt.xticks(fontsize=12)\n",
        "plt.yticks(fontsize=12)\n",
        "\n",
        "plt.tight_layout()\n",
        "#fig.suptitle(\"Resection vs resection + RT: N, s and fraction of GSCs\")\n",
        "plt.savefig(\"../Manuscript/images/png/sim_control_example_sims.png\")\n",
        "plt.show()"
      ],
      "id": "fig-resection-RT-model-sims",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Analyse proportion of stem cells\n"
      ],
      "id": "c8f4b30e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-GSC_proportion\n",
        "\n",
        "final_GSC_fraction = np.zeros(n_patients)\n",
        "\n",
        "for i in range(n_patients):\n",
        "    final_GSC_fraction[i] = s_save[i][-1]/N_save[i][-1]\n",
        "\n",
        "plt.hist(final_GSC_fraction,20)\n",
        "plt.xlabel('Final GSC fraction')\n",
        "plt.ylabel('count')\n",
        "plt.title(\"Histogram of final GSC fraction\")"
      ],
      "id": "fig-GSC_proportion",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Plot proportion of stem cells vs proliferation rate\n"
      ],
      "id": "bad9b01d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-GSC_proportion_vs_pro_rate\n",
        "\n",
        "plt.plot(pro_rates_sampled,final_GSC_fraction,'*')\n",
        "for i in range(0,n_patients,int(np.floor(n_patients/n_patients_to_plot))):\n",
        "    plt.plot(pro_rates_sampled[i],final_GSC_fraction[i],'r*')\n",
        "\n",
        "plt.xlabel('Proliferation rate [/year]')\n",
        "plt.ylabel('Final GSC fraction')"
      ],
      "id": "fig-GSC_proportion_vs_pro_rate",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Example tumour trajectories: ratio of compartments\n"
      ],
      "id": "bd6cf39b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-resection-RT-model-sims_diff_name\n",
        "#| fig-cap: Caption\n",
        "#| fig-alt: Alternative text\n",
        "\n",
        "n_patients_to_plot = 3\n",
        "\n",
        "fig, axs = plt.subplots(4,3, sharex=True) \n",
        "\n",
        "for i in range(0,n_patients,int(np.floor(n_patients/n_patients_to_plot))):\n",
        "    mv = mv_rho_scale*pro_rates_sampled[i]*np.ones(n) \n",
        "    ms = ms_mv_scale*mv[0]\n",
        "    mv[n-1] = 0 \n",
        "    fig.axes[0].plot(t_save_set[0][i],u_save_set[0][i][:,1]/u_save_set[0][i][:,0],alpha=0.5)\n",
        "    fig.axes[0].plot(t_save_set[0][i],2*(1-Ps_max)*ms*(1-N_save_set[0][i]/k)/(mv[0]*(1-N_save_set[0][i]/k)+delta_v[0]),'k--')\n",
        "    for j in range(1,n):\n",
        "        fig.axes[j].plot(t_save_set[0][i],u_save_set[0][i][:,j+1]/u_save_set[0][i][:,j],alpha=0.5)\n",
        "        fig.axes[j].plot(t_save_set[0][i],gmf.alpha_i(N_save_set[0][i],mv,k,delta_v,j),'k--')\n",
        "        # fig.axes[j].set(ylabel=r'$v_i/v_{i-1}$')\n",
        "    fig.axes[-1].plot(t_save_set[0][i],u_save_set[0][i][:,n]/u_save_set[0][i][:,n-1],alpha=0.5)\n",
        "    fig.axes[-1].plot(t_save_set[0][i],gmf.alpha_i(N_save_set[0][i],mv,k,delta_v,n-1),'k--')\n",
        "\n",
        "fig.axes[-1].set_xlim([0, 2000])\n",
        "# ax1.set_ylim([0, 2.55])\n",
        "fig.axes[0].set(ylabel=r'$v_1/s$')\n",
        "fig.axes[-1].set(ylabel=r'$v_n/v_{n-1}$')\n",
        "fig.supylabel('Compartment ratio')\n",
        "\n",
        "fig.axes[-2].set(xlabel='Time (days)')\n",
        "\n",
        "fig.suptitle(\"Ratio between compartments\")\n",
        "plt.show()"
      ],
      "id": "fig-resection-RT-model-sims_diff_name",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Plot doubling times and expected doubling time from rho\n"
      ],
      "id": "a7b1ed56"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.plot(pro_rates_sampled,tp2-tp1,'*')\n",
        "plt.plot(pro_rates_sampled,365*np.log(2)/pro_rates_sampled)\n",
        "plt.xlabel('rho [1/year]')\n",
        "plt.ylabel('T_2 [days]')\n",
        "plt.ylim(0,250)"
      ],
      "id": "2a4e9ae6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Calculate statistical difference between the real and simulated survival\n"
      ],
      "id": "c50b7a00"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: compare_survival\n",
        "\n",
        "# to compare survival we need a single DF that contains both simulated and real with a column idicating which is which.\n",
        "\n",
        "# need to create a structed array:\n",
        "dtype = [('event_indicator', bool), ('time', float)]\n",
        "time = np.zeros([len(historic_df)+n_patients])\n",
        "time[0:len(historic_df),] = np.array(historic_df[\"Overall Survival\"])\n",
        "time[len(historic_df):,] = surv_final[:,1]\n",
        "#event_indicators = np.ones([n_patients+num_simulated_patients])\n",
        "event_indicators = np.ones([len(historic_df)+n_patients])\n",
        "censored = np.zeros([len(historic_df)+n_patients])\n",
        "i_censored = len(historic_df) + np.where(np.abs(save_detect_t)<dt/2)[0]\n",
        "censored[i_censored] = 1\n",
        "structured_array = np.array( list(zip(event_indicators, time)) , dtype=dtype)\n",
        "structured_array = structured_array[censored==0]\n",
        "\n",
        "group = np.zeros(len(historic_df)+n_patients)\n",
        "group = group[censored==0]\n",
        "group[len(historic_df):] = 1\n",
        "chisq, p_value, stats, covariance = compare_survival(y = structured_array, group_indicator= group, return_stats=True)\n",
        "print(\"Statistical comparison of survival between real and simulated patients\")\n",
        "print(\"Chi square values = \" + str(chisq))\n",
        "print(\"P value = \" + str(p_value))\n",
        "print(stats)"
      ],
      "id": "compare_survival",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Kaplan Meier plot\n",
        "\n",
        "Plot the Kaplan Meier curve for the virtual patients compared to the real patients\n"
      ],
      "id": "ee6ad0b0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-KM_virtual_controls\n",
        "#| fig-cap: 'Comparison of simulated survival with resection alone and resection followed by radiotherapy, and real survival data.'\n",
        "#| fig-alt: Comparison of simulated survival.\n",
        "\n",
        "survival_df = pd.DataFrame(surv_final, columns=['Survival_Resect_RT','Survival_BMP4_1'])\n",
        "# has to be set to boolean not just integer\n",
        "survival_df['Status'] = np.abs(save_detect_t)>dt/2 \n",
        "survival_df = survival_df[survival_df['Status']]\n",
        "\n",
        "# Real survival data\n",
        "#time, survival_prob, conf_int = kaplan_meier_estimator(historic_df[censored_str], historic_df[survival_str], conf_type=\"log-log\")\n",
        "#plt.step(time, survival_prob, where=\"post\")\n",
        "#plt.fill_between(time, conf_int[0], conf_int[1], alpha=0.25, step=\"post\",  label='_nolegend_')\n",
        "\n",
        "# Resection + RT control\n",
        "time, survival_prob, conf_int = kaplan_meier_estimator(survival_df[\"Status\"], survival_df[\"Survival_Resect_RT\"], conf_type=\"log-log\")\n",
        "plt.step(time, survival_prob, where=\"post\")\n",
        "plt.fill_between(time, conf_int[0], conf_int[1], alpha=0.25, step=\"post\",  label='_nolegend_')\n",
        "\n",
        "# BMP4 + RT + resection\n",
        "time, survival_prob, conf_int = kaplan_meier_estimator(survival_df[\"Status\"], survival_df[\"Survival_BMP4_1\"], conf_type=\"log-log\")\n",
        "plt.step(time, survival_prob, where=\"post\")\n",
        "plt.fill_between(time, conf_int[0], conf_int[1], alpha=0.25, step=\"post\",  label='_nolegend_')\n",
        "\n",
        "# add the p-value:\n",
        "#plt.text(0.75, 0.75, \"p = \" + str(round(p_value,5)), horizontalalignment='center', verticalalignment='center', transform=plt.gca().transAxes)\n",
        "\n",
        "\n",
        "plt.xlim(0, 5000)\n",
        "plt.ylim(0, 1)\n",
        "plt.ylabel(\"Survival\", fontsize=14)\n",
        "plt.xlabel(\"Time (day)\", fontsize=14)\n",
        "plt.tick_params(top=True)\n",
        "#plt.title(\"Simulated survival\")\n",
        "plt.legend([\"Simulated control\",\"Simulated BMP4\"],fontsize=14)\n",
        "plt.xticks(fontsize=14)\n",
        "plt.yticks(fontsize=14)\n",
        "plt.tight_layout()\n",
        "plt.savefig(\"../Manuscript/images/png/simulate_control_KM.png\")\n",
        "plt.show()"
      ],
      "id": "fig-KM_virtual_controls",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Joint plot\n",
        "\n",
        "Plot the KM and example trajectories as subplots\n"
      ],
      "id": "48da7e4c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-KM_and_trajectories\n",
        "#| layout-ncol: 2\n",
        "#| fig-cap: joint caption\n",
        "#| fig-subcap:\n",
        "#|   - First\n",
        "#|   - Second\n",
        "\n",
        "plt.figure()\n",
        "time, survival_prob, conf_int = kaplan_meier_estimator(survival_df[\"Status\"], survival_df[\"Survival_Resect_RT\"], conf_type=\"log-log\")\n",
        "plt.step(time, survival_prob, where=\"post\")\n",
        "plt.fill_between(time, conf_int[0], conf_int[1], alpha=0.25, step=\"post\",  label='_nolegend_')\n",
        "time, survival_prob, conf_int = kaplan_meier_estimator(historic_df[censored_str], historic_df[survival_str], conf_type=\"log-log\")\n",
        "plt.step(time, survival_prob, where=\"post\")\n",
        "plt.fill_between(time, conf_int[0], conf_int[1], alpha=0.25, step=\"post\",  label='_nolegend_')\n",
        "plt.ylim(0, 1)\n",
        "plt.ylabel(\"Survival\")\n",
        "plt.xlabel(\"Time (day)\")\n",
        "plt.legend([\"Simulated\", \"Real\"])\n",
        "plt.show()\n",
        "\n",
        "plt.figure()\n",
        "\n",
        "for i in range(0,n_patients,5):\n",
        "    plt.plot(t_save[i],N_save[i],color='grey',alpha=0.5)\n",
        "    plt.plot(save_detect_t[i],save_detect_size[i],'r*')\n",
        "\n",
        "plt.xlabel('Time (days)')\n",
        "plt.ylabel('Tumor size')\n",
        "plt.show()"
      ],
      "id": "fig-KM_and_trajectories",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# plot for SMB\n"
      ],
      "id": "702b5735"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "index_to_plot = [20,30,40, 50,70, 90,100, 130, 150]\n",
        "for i in index_to_plot:\n",
        "    plt.plot(t_save[i],N_save[i],color='grey',alpha=0.5)\n",
        "    plt.plot(save_detect_t[i],save_detect_size[i],'r*')\n",
        "\n",
        "plt.xlabel('Time (days)', fontsize=14)\n",
        "plt.ylabel('Tumor size', fontsize=14)\n",
        "plt.title(\"Example trajectories\", fontsize=14)\n",
        "plt.xticks(fontsize=12)\n",
        "plt.yticks(fontsize=12)\n",
        "plt.tight_layout()\n",
        "#plt.savefig(\"../SMB_figs/example_trajectories.svg\")\n",
        "plt.show()"
      ],
      "id": "1d506fd3",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\nicho\\anaconda3\\envs\\CGM_analysis\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}